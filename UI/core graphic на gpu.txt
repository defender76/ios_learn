
core graphic на gpu

слои можно перерисовывать только часть
слои всегда анимируются 

uiview
нет хранилища чтобы контент сохранить
нет методов чтобы лейаутится не хранит координаты

все в caLayer 

core animation предоставляет caLayer

ui view обработка татчей и респондер чейн 
тени, закругления, трансформация

frame вычисляемое свойство 

catransaction время и тайминг анимации

layer  спрашивает делегата нужно ли анимировать. 

если анимация основана на таймере можно к презентейшен слой 
view model layer presentation layer (view.layer.presentation копия леера с текущими значениями во время презентации)
render слои  можем presentation слой менять  removedOnCompletion = false результат анимации не удалится  fillMode = forwards (конечное состояние)  при добавлении новой анимации удаляется старая. 
 caAnimationGroup группировать  renderServer caTransition.commit() в конце текущего ранлупа применяет настройки схлопывает в одну и передает в приватный слой caLayer. И пишет на openGL и отдает на GPU  Экраном владеет renderServer   Собирает процессы со всех приложений и собирает шейдеры и отображает.   мультитаскин и поэтому нужен отдельный сервер. Исполняет инструкции которые отдает CoreAnimation + следит за таймингом CADisplayLink рендер сервер готовит и знает когда перерисовать дисплей.   Когда ваше приложение падает до 10 fps iOS продолжает работать в 60 fps.   чтобы из Metal показать на экране надо специальный слой. 

берем таймер сколько время с последнего кадра и считаем изменение значения.  не используйте NSTime и не имеет верхней планки по времени fire. Может больше времени и можешь кадр пропустить. Лучше CaDisplayLink. 

